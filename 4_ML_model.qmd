---
title: Naceňovací ML model
author: Arnold Kakas
format: html
date: today
theme: 
  - flatly
  - Style.scss
toc: true
toc-depth: 4
code-fold: true
code-summary: "Kód"
execute:
  warning: false  
fig-cap-location: bottom
fig-align: center
crossref: 
  fig-prefix: "Graf"
tbl-cap-location: bottom
---

## Úvod

tidymodels, xgboost

## Explainable ML

V rámci strojového učenia predstavuje koncept "explainable ML" (vysvetliteľné strojové učenie) kľúčový posun smerom k transparentnosti a interpretovateľnosti modelov, ktoré sú často vnímané ako "black box". Napriek tomu, že modely ako XGBoost ponúkajú výnimočnú prediktívnu silu, ich interné rozhodovacie procesy môžu byť zložité a nejasné. Toto vnímanie komplikuje dôveru a akceptáciu modelov v kritických aplikáciách, kde je potrebné pochopenie dôvodov za predikciami.

Vysvetliteľné ML sa snaží preklenúť túto priepasť, poskytujúc nástroje a metódy na objasnenie, ako modely dospeli k svojim rozhodnutiam. Knihovne ako "vip" a metódy ako SHAP (Shapley Additive exPlanations) hodnoty umožňujú analytikom a vývojárom lepšie pochopiť príspevky jednotlivých funkcií k výslednému predikovanému výstupu. Táto schopnosť detailne rozložiť predikčný proces umožňuje nielen hlbšiu analýzu a optimalizáciu modelov, ale tiež zvyšuje transparentnosť a dôveru zo strany koncových užívateľov.

Dôležitosť "explainable ML" naberá na váhe najmä v sektoroch, kde sú dôsledky rozhodnutí založených na predikciách modelu vysoké, ako sú zdravotníctvo, financie alebo právo. V týchto oblastiach je kľúčové, aby boli modely nielen presné, ale aj ich rozhodnutia comprehenzívne a spravodlivé. Vysvetliteľné strojové učenie tak stojí v centre úsilia o vytvorenie technológií, ktoré sú nielen inteligentné, ale aj zrozumiteľné a etické.



## Načítanie knižníc a dát

```{r}
#| echo: true
#| code-summary: "Knižnice"
# import libraries
if (!require("pacman")) {
  install.packages("pacman")
}

pacman::p_load(
  sf,
  tidyverse,
  tidymodels,
  GGally,
  vip,
  SHAPforxgboost,
  parallel,
  dataPreparation,
  doParallel,
  extrafont
)

loadfonts(device = "win")

unregister_dopar <- function() {
  env <- foreach:::.foreachGlobals
  rm(list = ls(name = env), pos = env)
}
```

```{r}
#| echo: true
#| code-summary: "Dáta"
# import data
apartments_analysis_data <- readRDS("data/apartments_final_data.rds") |>
  filter(!is.na(price)) |>
  mutate(
    coord = st_coordinates(st_centroid(geometry)),
    lon = coord[, 1],
    lat = coord[, 2]
  ) |>
  select(-coord) # Optionally remove the original coordinates column

# remove geometry since we have coordinates now
apartments_analysis_data$geometry <- NULL
```

## Tidymodels framework

<br>Tidymodels je súbor knižníc v R, ktorý poskytuje jednotné a flexibilné rozhranie pre celý proces strojového učenia, od predspracovania dát cey ich analýzu až po modelovanie. Vytvorenie modelu v rámci frameworku tidymodels pozostáva z niekoľkých základných krokov:

* **Príprava a rozdelenie dát:** Prvý krok je rozdelenie nášho "dátového budgetu". Typicky sa dáta delia na trénovaciu (slúži na odhad parametrov modelu) a testovaciu (slúži na nezávislé zhodnotenie modelu) sadu pomocou funkcie initial_split(). Tento krok je základom pre overovanie modelu a zabránenie overfittingu. S využitím vfold_cv() alebo podobných funkcií vytvoríme schému krížovej validácie (rôzne verzie tréningových dát - tzv. "folds"), ktorá sa použije na evaluáciu modelu.
<br>Ako rozdelenie na tréningovú a testovaciu sadu, tak aj vytvorenie validačných schém umožnuje specifikovať premennú, ktorej rozdelenie ostane (približne) zachované (strata =).

<center>![Rozdelenie dátového budgetu. Zdroj: https://www.tidymodels.org/start/resampling/#data-split](data/resampling.svg)
</center>

* **Vytvorenie receptu (recipe):** recipe() definuje predspracovanie dát, vrátane výberu premenných, transformácií, normalizácie, kódovania kategorických premenných a riešenia chýbajúcich hodnôt. Jednotlivé kroky sa pridávajú pomocou step_*() funkcií. Recipies zabezpečujú, že predspracovanie je konzistentné a reprodukovateľné. 

* **Špecifikácia modelu:** Model sa špecifikuje nezávisle od dát. Pomocou funkcií ako linear_reg(), rand_forest(), boost_tree() a iných definujeme typ modelu, mód (regresia, klasifikácia), engine(xgboost, lightgbm...) a jeho hlavné parametre bez toho, aby sme ich ihneď fitovali na dáta. Tento krok umožňuje flexibilitu v experimentovaní s rôznymi modelmi.

* **Nastavenie workflow:** workflow() integruje recept a model do jednotného objektu. Workflow umožňuje efektívnejšie spracovanie, keďže spojíme predspracovanie dát a modelovanie do jednej operácie, čo zjednodušuje evaluáciu a porovnávanie modelov.

* **Výber a nastavenie hyperparametrov:** Pomocou parameters() môžeme definovať a prispôsobiť rozsahy hyperparametrov pre tuning modelu. Tidymodels ponúka rôzne metódy pre vyhľadávanie optimálnych hodnôt, napr. tune_grid(), tune_bayes(), tune_race() a iné.

* **Krížová validácia a tuning modelu:** Tuning hyperparametrov prebieha na trénovacej sade (resp. na jednotlivých "fold-och") s cieľom nájsť najlepšiu kombináciu hyperparametrov. Najlepší model vyberieme pomocou funkcie select_best(), pričom špecifikujeme metriku, podľa ktorej model vyberáme.

* **Finalizácia a fitovanie modelu:** Po vybraní najlepších hyperparametrov finalizujeme model pomocou finalize_model() a potom ho fitujete na trénovacie dáta s fit(). Tento krok produkuje finálny model pripravený na evaluáciu a predikcie.

* **Evaluácia modelu:** Pomocou testovacej sady dát overíme výkonnosť modelu. Metriky ako RMSE, presnosť (accuracy),  AUC a mnoho iných (výber by mal zodpovedať nášmu cieľu, čo platí najmä pri klasifikácii) poskytujú hodnotenie, ako dobre model predpovedá nevidené dáta.

Tieto kroky poskytujú ucelený prístup k vytváraniu, optimalizácii a evaluácii prediktívnych modelov. Tidymodels zabezpečuje konzistenciu a reprodukovateľnosť po celom procese.

Toto je opis základného procesu tvorby ML modelu pomocou tidymodels frameworku. Je možné samozrejme vytvoriť aj omnoho komplikovanejší proces s postupným tuningom hyperparametrov, tvorbou stacked modelu (meta-learner modelu) atď.

## Tvorba modelu
```{r}
#| echo: true
#| code-summary: "Rozdelenie dát"

# split dataframes to train(80)/test(20)
set.seed(123)
apartments_train_split <- initial_split(apartments_analysis_data, prop = 0.7, strata = price)

apartments_train <- training(apartments_train_split)
apartments_test <- testing(apartments_train_split)

folds <- vfold_cv(apartments_train, v = 5, strata = price)
```


```{r}
#| echo: true
#| code-summary: "Recept"

apartments_xgboost_recipe <- recipe(apartments_train, price ~ .) |>
  step_rm(name_nsi) |>
  step_string2factor(all_nominal_predictors()) |>
  step_impute_knn(all_nominal_predictors()) |>
  step_unknown(all_nominal_predictors()) |>
  step_dummy(all_nominal_predictors())
```


```{r}
#| eval: false
#| echo: true
#| code-summary: "Špeficikácia modelu"

xgb_model <-
  boost_tree(
    trees = tune(), loss_reduction = tune(),
    tree_depth = tune(), min_n = tune(),
    mtry = tune(), sample_size = tune(),
    learn_rate = tune()
  ) |>
  set_mode("regression") |>
  set_engine("xgboost")
```

```{r}
#| eval: false
#| echo: true
#| code-summary: "Workflow"

apartments_workflow <- workflow() |>
  add_recipe(apartments_xgboost_recipe) |>
  add_model(xgb_model)
```

```{r}
#| eval: false
#| echo: true
#| code-summary: "Výber parametrov"

apartments_xgboost_params <- parameters(
  trees(), learn_rate(), loss_reduction(),
  tree_depth(), min_n(),
  sample_size = sample_prop(),
  finalize(mtry(), apartments_train)
)

apartments_xgboost_params <- apartments_xgboost_params %>% update(trees = trees(c(300, 600)))
```
<br>Pri tuningu použijeme paralelné spracovanie na x - 2 jadrách. Niektoré algoritmy umožnujú aj spracovanie pomocou GPU ak je dostupná kompatibilná grafická karta (bavíme sa o tvorbe modelu na lokálnom zariadení, samozrejme v produkcii je vhodnejšie vyižiť sluzby ako GCP, AWS a iné)

```{r}
#| eval: false
#| echo: true
#| code-summary: "Tuning parametrov"

registerDoParallel(cores = detectCores() - 2)

xgboost_tune <-
  apartments_workflow %>%
  tune_bayes(
    resamples = folds,
    param_info = apartments_xgboost_params,
    iter = 30,
    metrics = metric_set(rmse, mape),
    control = control_bayes(
      no_improve = 10,
      save_pred = T, verbose = F
    )
  )

unregister_dopar()
```

```{r}
#| eval: false
#| echo: true
#| code-summary: "Finalizácia modelu"
apartments_best_model <- select_best(xgboost_tune, "rmse")
apartments_final_model <- finalize_model(xgb_model, apartments_best_model)
apartments_workflow <- apartments_workflow |> update_model(apartments_final_model)
apartments_xgb_fit <- fit(apartments_workflow, data = apartments_train)

saveRDS(apartments_xgb_fit, "data/xgb_fit.RDS")
```

```{r}
#| echo: false
apartments_xgb_fit <- readRDS("data/xgb_fit.RDS")
```

```{r}
#| eval: false
#| echo: true
#| code-summary: "Výsledné metriky"
apartments_final_res <- last_fit(apartments_xgb_fit, apartments_train_split)
collect_metrics(apartments_final_res) |> mutate(.estimate = round(.estimate, 2))
```

## Vyhodnotenie modelu

```{r}
#| echo: true
#| code-summary: "Porovnanie predikcie s reálnou cenou"
apartments_pred <-
  predict(apartments_xgb_fit, apartments_test) |>
  bind_cols(apartments_test)

plot1 <-
  apartments_pred |>
  ggplot(aes(x = .pred, y = price)) +
  geom_point() +
  geom_smooth(method = "loess", color = "red") +
  scale_y_continuous(labels = function(x) format(x, big.mark = " ", scientific = FALSE), breaks = c(200000, 400000, 600000)) +
  scale_x_continuous(labels = function(x) format(x, big.mark = " ", scientific = FALSE), breaks = c(200000, 400000, 600000)) +
  labs(
    title = NULL,
    x = "Predikovaná cena",
    y = "Reálna Cena"
  ) +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank(),
    text = element_text(family = "Courier New", size = 12)
  ) +
  coord_fixed()

plot2 <-
  apartments_pred |>
  select(predikcia = .pred, realita = price) |>
  gather(key, value) |>
  ggplot(aes(x = value, color = key)) +
  geom_density(alpha = .2) +
  labs(
    title = NULL,
    x = "Cena",
    y = "Hustota",
    color = ""
  ) +
  scale_y_continuous(labels = function(x) format(x, big.mark = " ", scientific = FALSE)) +
  scale_x_continuous(labels = function(x) format(x, big.mark = " ", scientific = FALSE)) +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    text = element_text(family = "Courier New", size = 12)
  )
```

```{r}
#| echo: false
plot1
```

```{r}
#| echo: false
plot2
```


```{r}
#| echo: true
#| code-summary: "vip"
apartments_xgb_fit |>
  fit(data = apartments_train) |>
  pull_workflow_fit() |>
  vip(geom = "point", include_type = TRUE) + 
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank(),
    text = element_text(family = "Courier New", size = 12)
  ) + 
  labs(
    y = "Dôležitosť",
    x = "Premenná"
  )
```



```{r}
#| echo: true
#| code-summary: "SHAP"
#| fig-width: 8
fitted_data <- apartments_xgboost_recipe %>%
  prep() %>%
  bake(new_data = apartments_analysis_data) %>%
  select(-price)

shap_long <- shap.prep(xgb_model = extract_fit_engine(apartments_xgb_fit), 
                        X_train = fitted_data %>% as.matrix(), top_n = 15) |> 
  mutate(mean_value = round(mean_value, 0))
                       
shap_plot <- shap.plot.summary(shap_long, scientific = FALSE) +
  geom_text(data = unique(shap_long[, c("variable", "mean_value")]),
            aes(x = variable, y = -Inf, label = format(mean_value, big.mark = " ", scientific = FALSE)),
            size = 3, alpha = 0.7,
            hjust = -0.2,
            check_overlap = TRUE,
            family = "Courier New") +
  scale_y_continuous(labels = function(x) format(x, big.mark = " ", scientific = FALSE)) +
  scale_color_gradient(low = "blue", high = "red",
                      breaks = c(0,1),
                      labels = c("nízka", "vysoká"),
                      guide = guide_colorbar(barwidth = 12, barheight = 0.3)) + # Customize based on your exact needs
  labs(x = "Premenná",
       y = "SHAP hodnota (vplyv na predikovanú cenu)",
       color = "Hodnota premennej  "
       ) +
  theme(
    panel.grid.minor = element_blank(),
    text = element_text(family = "Courier New", size = 12),
    legend.position = "bottom"
  )

shap_plot$layers[[3]] <- NULL

shap_plot
```

# Uloženie modelu a dát pre aplikáciu

```{r}
#| eval: false
#| echo: true
#| code-summary: "Porovnanie predikcie s reálnou cenou"
# save model
saveRDS(apartments_xgb_fit, "data/model.RDS")

# save other data for app
conditions <- apartments_analysis_data |>
  select(condition) |>
  distinct()
saveRDS(conditions, "data/conditions.RDS")

certificate <- apartments_analysis_data |>
  select(certificate) |>
  distinct()
saveRDS(certificate, "data/certificate.RDS")

type <- apartments_analysis_data |>
  select(type) |>
  distinct()
saveRDS(type, "data/type.RDS")
```